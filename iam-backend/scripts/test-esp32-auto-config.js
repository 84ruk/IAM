#!/usr/bin/env node

/**
 * Script de Prueba - Configuraci√≥n Autom√°tica ESP32
 * 
 * Este script prueba todas las funcionalidades implementadas:
 * 1. Generaci√≥n de c√≥digo base ESP32
 * 2. Configuraci√≥n autom√°tica
 * 3. Generaci√≥n de c√≥digos QR
 * 4. Endpoints p√∫blicos
 * 5. Almacenamiento temporal
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuraci√≥n
const BASE_URL = process.env.BACKEND_URL || 'http://localhost:3001';
const JWT_TOKEN = process.env.JWT_TOKEN;

const api = axios.create({
  baseURL: BASE_URL,
  headers: {
    'Authorization': `Bearer ${JWT_TOKEN}`,
    'Content-Type': 'application/json'
  }
});

// Colores para consola
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`‚úÖ ${message}`, 'green');
}

function logError(message) {
  log(`‚ùå ${message}`, 'red');
}

function logInfo(message) {
  log(`‚ÑπÔ∏è  ${message}`, 'blue');
}

function logWarning(message) {
  log(`‚ö†Ô∏è  ${message}`, 'yellow');
}

async function testESP32AutoConfig() {
  log('üöÄ Iniciando Pruebas de Configuraci√≥n Autom√°tica ESP32', 'bright');
  log('==================================================', 'bright');
  
  let testsPassed = 0;
  let testsFailed = 0;

  try {
    // Test 1: Verificar autenticaci√≥n
    log('\n1Ô∏è‚É£ Verificando autenticaci√≥n...', 'cyan');
    try {
      const authResponse = await api.get('/users/profile');
      logSuccess('Autenticaci√≥n correcta');
      logInfo(`Usuario: ${authResponse.data.email}`);
      logInfo(`Empresa ID: ${authResponse.data.empresaId}`);
      testsPassed++;
    } catch (error) {
      logError('Error de autenticaci√≥n');
      logWarning('Aseg√∫rate de configurar JWT_TOKEN en las variables de entorno');
      logWarning('Ejecuta: export JWT_TOKEN="tu-token-aqui"');
      testsFailed++;
      return;
    }

    // Test 2: Obtener ubicaciones
    log('\n2Ô∏è‚É£ Obteniendo ubicaciones...', 'cyan');
    try {
      const ubicacionesResponse = await api.get('/ubicaciones');
      const ubicaciones = ubicacionesResponse.data;
      
      if (ubicaciones.length === 0) {
        logWarning('No hay ubicaciones. Creando ubicaci√≥n de prueba...');
        const nuevaUbicacion = await api.post('/ubicaciones', {
          nombre: 'Ubicaci√≥n de Prueba ESP32',
          descripcion: 'Ubicaci√≥n para pruebas de configuraci√≥n autom√°tica',
          direccion: 'Direcci√≥n de Prueba',
          ciudad: 'Ciudad de Prueba',
          pais: 'Pa√≠s de Prueba',
          codigoPostal: '00000'
        });
        ubicaciones.push(nuevaUbicacion.data);
        logSuccess('Ubicaci√≥n de prueba creada');
      }
      
      logSuccess(`Ubicaciones obtenidas: ${ubicaciones.length}`);
      testsPassed++;
    } catch (error) {
      logError(`Error obteniendo ubicaciones: ${error.response?.data?.message || error.message}`);
      testsFailed++;
      return;
    }

    // Test 3: Descargar c√≥digo base ESP32
    log('\n3Ô∏è‚É£ Descargando c√≥digo base ESP32...', 'cyan');
    try {
      const codigoResponse = await api.get('/mqtt-sensor/esp32/codigo-base', {
        responseType: 'text'
      });
      
      if (codigoResponse.data && codigoResponse.data.includes('ESP32 Auto-Configuration')) {
        logSuccess('C√≥digo base ESP32 descargado correctamente');
        
        // Guardar c√≥digo en archivo
        const codigoPath = path.join(__dirname, 'esp32-base-code-test.ino');
        fs.writeFileSync(codigoPath, codigoResponse.data);
        logInfo(`C√≥digo guardado en: ${codigoPath}`);
        testsPassed++;
      } else {
        logError('C√≥digo base no contiene contenido esperado');
        testsFailed++;
      }
    } catch (error) {
      logError(`Error descargando c√≥digo base: ${error.response?.data?.message || error.message}`);
      testsFailed++;
    }

    // Test 4: Descargar instrucciones de instalaci√≥n
    log('\n4Ô∏è‚É£ Descargando instrucciones de instalaci√≥n...', 'cyan');
    try {
      const instruccionesResponse = await api.get('/mqtt-sensor/esp32/instrucciones-instalacion', {
        responseType: 'text'
      });
      
      if (instruccionesResponse.data && instruccionesResponse.data.includes('Instrucciones de Instalaci√≥n')) {
        logSuccess('Instrucciones de instalaci√≥n descargadas correctamente');
        
        // Guardar instrucciones en archivo
        const instruccionesPath = path.join(__dirname, 'instrucciones-instalacion-test.md');
        fs.writeFileSync(instruccionesPath, instruccionesResponse.data);
        logInfo(`Instrucciones guardadas en: ${instruccionesPath}`);
        testsPassed++;
      } else {
        logError('Instrucciones no contienen contenido esperado');
        testsFailed++;
      }
    } catch (error) {
      logError(`Error descargando instrucciones: ${error.response?.data?.message || error.message}`);
      testsFailed++;
    }

    // Test 5: Generar c√≥digo personalizado
    log('\n5Ô∏è‚É£ Generando c√≥digo personalizado...', 'cyan');
    try {
      const codigoPersonalizadoResponse = await api.post('/mqtt-sensor/esp32/codigo-personalizado', {
        sensores: [
          { tipo: 'TEMPERATURA', nombre: 'Sensor Temperatura Test', pin: 4 },
          { tipo: 'HUMEDAD', nombre: 'Sensor Humedad Test', pin: 4 }
        ]
      });
      
      if (codigoPersonalizadoResponse.data.success) {
        logSuccess('C√≥digo personalizado generado correctamente');
        logInfo('Incluye: includes, definitions, setupCode, loopCode');
        testsPassed++;
      } else {
        logError('Error generando c√≥digo personalizado');
        testsFailed++;
      }
    } catch (error) {
      logError(`Error generando c√≥digo personalizado: ${error.response?.data?.message || error.message}`);
      testsFailed++;
    }

    // Test 6: Generar configuraci√≥n autom√°tica
    log('\n6Ô∏è‚É£ Generando configuraci√≥n autom√°tica...', 'cyan');
    try {
      const configData = {
        deviceName: 'ESP32_Test_Device',
        wifiSSID: 'TestWiFi',
        wifiPassword: 'testpassword123',
        ubicacionId: 1,
        sensores: [
          { tipo: 'TEMPERATURA', nombre: 'Sensor Temperatura', pin: 4, enabled: true },
          { tipo: 'HUMEDAD', nombre: 'Sensor Humedad', pin: 4, enabled: true },
          { tipo: 'PESO', nombre: 'Sensor Peso', pin: 2, enabled: false },
          { tipo: 'PRESION', nombre: 'Sensor Presi√≥n', pin: 21, enabled: false }
        ]
      };

      const configResponse = await api.post('/mqtt-sensor/esp32/configuracion-automatica', configData);
      
      if (configResponse.data.success) {
        logSuccess('Configuraci√≥n autom√°tica generada correctamente');
        
        const resultado = configResponse.data;
        logInfo(`Device ID: ${resultado.credentials?.mqttUsername}`);
        logInfo(`MQTT Topic: ${resultado.credentials?.mqttTopic}`);
        logInfo(`QR Code: ${resultado.qrCode ? 'Generado' : 'No disponible'}`);
        logInfo(`Instrucciones: ${resultado.instrucciones?.length || 0} pasos`);
        
        // Guardar configuraci√≥n en archivo
        const configPath = path.join(__dirname, 'esp32-config-test.json');
        fs.writeFileSync(configPath, JSON.stringify(resultado, null, 2));
        logInfo(`Configuraci√≥n guardada en: ${configPath}`);
        
        testsPassed++;
        
        // Test 7: Probar endpoint p√∫blico (simular ESP32)
        log('\n7Ô∏è‚É£ Probando endpoint p√∫blico (simulaci√≥n ESP32)...', 'cyan');
        try {
          const deviceId = resultado.credentials?.mqttUsername;
          if (deviceId) {
            const publicResponse = await axios.get(`${BASE_URL}/mqtt-sensor/esp32/config/${deviceId}`);
            
            if (publicResponse.data.success) {
              logSuccess('Endpoint p√∫blico funciona correctamente');
              logInfo('ESP32 puede obtener configuraci√≥n autom√°ticamente');
              testsPassed++;
            } else {
              logError('Endpoint p√∫blico no retorn√≥ configuraci√≥n v√°lida');
              testsFailed++;
            }
          } else {
            logWarning('No se pudo probar endpoint p√∫blico - deviceId no disponible');
            testsFailed++;
          }
        } catch (error) {
          logError(`Error probando endpoint p√∫blico: ${error.response?.data?.message || error.message}`);
          testsFailed++;
        }
        
      } else {
        logError(`Error generando configuraci√≥n: ${configResponse.data.message}`);
        testsFailed++;
      }
    } catch (error) {
      logError(`Error en configuraci√≥n autom√°tica: ${error.response?.data?.message || error.message}`);
      testsFailed++;
    }

    // Test 8: Verificar estado ESP32 (simulaci√≥n)
    log('\n8Ô∏è‚É£ Verificando estado ESP32 (simulaci√≥n)...', 'cyan');
    try {
      const deviceId = 'esp32_test_device_' + Date.now();
      const statusResponse = await api.get(`/mqtt-sensor/esp32/status/${deviceId}`);
      
      if (statusResponse.data) {
        logSuccess('Verificaci√≥n de estado funciona correctamente');
        logInfo(`Estado: ${JSON.stringify(statusResponse.data)}`);
        testsPassed++;
      } else {
        logError('Verificaci√≥n de estado no retorn√≥ datos');
        testsFailed++;
      }
    } catch (error) {
      logError(`Error verificando estado: ${error.response?.data?.message || error.message}`);
      testsFailed++;
    }

  } catch (error) {
    logError(`Error general en las pruebas: ${error.message}`);
    testsFailed++;
  }

  // Resumen de resultados
  log('\nüìä RESUMEN DE PRUEBAS', 'bright');
  log('====================', 'bright');
  log(`‚úÖ Pruebas exitosas: ${testsPassed}`, 'green');
  log(`‚ùå Pruebas fallidas: ${testsFailed}`, 'red');
  log(`üìà Tasa de √©xito: ${((testsPassed / (testsPassed + testsFailed)) * 100).toFixed(1)}%`, 'cyan');
  
  if (testsFailed === 0) {
    log('\nüéâ ¬°Todas las pruebas pasaron exitosamente!', 'bright');
    log('La funcionalidad de configuraci√≥n autom√°tica ESP32 est√° funcionando correctamente.', 'green');
  } else {
    log('\n‚ö†Ô∏è  Algunas pruebas fallaron. Revisa los errores arriba.', 'yellow');
  }

  // Informaci√≥n adicional
  log('\nüìã ARCHIVOS GENERADOS:', 'cyan');
  log('=====================', 'cyan');
  const files = [
    'esp32-base-code-test.ino',
    'instrucciones-instalacion-test.md',
    'esp32-config-test.json'
  ];
  
  files.forEach(file => {
    const filePath = path.join(__dirname, file);
    if (fs.existsSync(filePath)) {
      const stats = fs.statSync(filePath);
      log(`üìÑ ${file} (${(stats.size / 1024).toFixed(1)} KB)`, 'green');
    } else {
      log(`‚ùå ${file} (no generado)`, 'red');
    }
  });

  log('\nüîß PR√ìXIMOS PASOS:', 'cyan');
  log('=================', 'cyan');
  log('1. Revisa los archivos generados para verificar el contenido', 'blue');
  log('2. Sube el c√≥digo base ESP32 a un dispositivo real', 'blue');
  log('3. Prueba la configuraci√≥n autom√°tica con un ESP32 f√≠sico', 'blue');
  log('4. Verifica que los datos lleguen al dashboard', 'blue');
}

// Ejecutar pruebas
if (require.main === module) {
  testESP32AutoConfig().catch(error => {
    logError(`Error ejecutando pruebas: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { testESP32AutoConfig }; 